<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Viewing</title>
</head>
<body>
    <canvas id="webgl-canvas" width="500" height="500"></canvas>
<!-- include gl-matrix library for matrix inversion -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
<script>
// Vertex shader source code
const vertexShaderSource = `
    attribute vec2 aPosition;
    uniform mat3 mMatrix;
    uniform mat3 vMatrix;
    uniform mat3 pMatrix;

    void main() {
        vec3 hPosition = vec3(aPosition, 1.0);
        gl_Position = vec4(pMatrix * vMatrix * mMatrix * hPosition, 1.0); 
        gl_PointSize = 5.0;
    }
`;
</script>
<script>
    // Fragment shader source code
    const fragmentShaderSource = `
        precision mediump float;
        uniform vec4 uColor;

        void main() {
            gl_FragColor = uColor;
        }
    `;
</script>
<script type="text/javascript" src="setupShader.js"></script>
<script>


function setIdentityMatrix () {
    return new Float32Array([
        1,0,0,
        0,1,0,
        0,0,1,
    ])
}

function multiplyMatrix3x3(a, b) {
    let result = new Array(9).fill(0);

    for (let col = 0; col < 3; col++) {  
        for (let row = 0; row < 3; row++) {  
            let sum = 0;
            for (let k = 0; k < 3; k++) {  
                sum += a[k * 3 + row] * b[col * 3 + k];
            }
            result[col * 3 + row] = sum;
        }
    }

    return result;
}

// Functions to create transformation matrices we set before
function setRotationMatrix(angle){
    const rad = angle * Math.PI / 180;
    const cosAngle = Math.cos(rad);
    const sinAngle = Math.sin(rad);
    return [
            cosAngle,   sinAngle, 0.0,
            -sinAngle,  cosAngle, 0.0,
            0.0,        0.0,      1.0,
        ];
}

function setTranslationMatrix(tx, ty) {
    return [
            1, 0, 0,
            0, 1, 0,
            tx,ty,1,
        ];
}

function setScalingMatrix(sx, sy) {
    return [
            sx, 0,  0,
            0,  sy, 0,
            0,  0,  1,
        ];
}

// Helper function to set rectangle vertices with width and height
function setRectangle (width, height) {
    return new Float32Array([
        0, 0, width, 0, 0, height,
        width, 0, 0, height, width, height,
    ])
}

class Shape {
    constructor(vertices, mMatrix, color) {
        this.vertices = vertices;
        this.mMatrix = mMatrix;
        this.color = color;
    }
    draw(parentMatrix = setIdentityMatrix()) {
        const buffer = gl.createBuffer();

        // pass vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // pass vMatrix and color
        const combinedMatrix = multiplyMatrix3x3(parentMatrix, this.mMatrix);
        gl.uniformMatrix3fv(mMatrixLocation, false, new Float32Array(combinedMatrix));
        gl.uniform4f(colorLocation, this.color[0], this.color[1], this.color[2], this.color[3]);

        gl.drawArrays(gl.TRIANGLES, 0, this.vertices.length / 2);
    }
}   

class ObjectWebGL {
    constructor(mMatrix = setIdentityMatrix()) {
        this.shapes = [];
        this.mMatrix = mMatrix;
        this.children = [];
    }

    local_transform(matrix){
        this.mMatrix = multiplyMatrix3x3(this.mMatrix, matrix);
    }

    draw(parentMatrix = setIdentityMatrix()) {
        const combinedMatrix = multiplyMatrix3x3(parentMatrix, this.mMatrix);
        for (const shape of this.shapes) {
            shape.draw(combinedMatrix);
        }
        for (const child of this.children) {
            child.draw(combinedMatrix);
        }
    }
}

// make soldier object
const soldier = new ObjectWebGL(setTranslationMatrix(200, 80));
const head = new Shape(setRectangle(20, 25), setTranslationMatrix(15, 150), [1, 0.8, 0.6, 1]);
const body = new Shape(setRectangle(50, 100), setTranslationMatrix(0, 50), [0.6, 0.6, 0.8, 1]);
const leftLeg = new Shape(setRectangle(15, 50), setTranslationMatrix(0, 0), [0.5, 0.3, 0.2, 1]);
const rightLeg = new Shape(setRectangle(15, 50), setTranslationMatrix(35, 0), [0.5, 0.3, 0.2, 1]);    
soldier.shapes.push(head);
soldier.shapes.push(body);
soldier.shapes.push(leftLeg);
soldier.shapes.push(rightLeg);

const arm = new ObjectWebGL(multiplyMatrix3x3(setTranslationMatrix(42.5, 140), setRotationMatrix(-120)));
arm.updateMatrix = function() {
    this.mMatrix = multiplyMatrix3x3(this.translationMatrix, setRotationMatrix(this.startAngle + this.angle));
}
arm.shapes.push(new Shape(setRectangle(15, 50), setIdentityMatrix(), [0.5, 0.3, 0.2, 1]));

const sword = new ObjectWebGL(multiplyMatrix3x3(setTranslationMatrix(9, 43), setRotationMatrix(110)));
const blade = new Shape(setRectangle(5, 100), setIdentityMatrix(), [0.9, 0.9, 0.9, 1]);
const guard = new Shape(setRectangle(15, 6), setTranslationMatrix(-5, 13), [0.9, 0.9, 0.9, 1]);
const tip = new Shape(new Float32Array([
    0,100, 5,100, 2.5,110,
]), setIdentityMatrix(), [1.0, 1.0, 1.0, 1]);
sword.shapes.push(blade);
sword.shapes.push(guard); 
sword.shapes.push(tip);

soldier.children.push(arm);
arm.children.push(sword);

// make stones as the background
stones = new ObjectWebGL();
for (let i = 0; i < 500; i++) {
    const x = Math.random() * 1000 - 250;
    const y = Math.random() * 180;
    const width = Math.random() * 20 + 10;
    const height = Math.random() * 15 + 5;
    const scale = 1 - (y / 250);
    const scaledWidth = width * scale;
    const scaledHeight = height * scale;
    stones.shapes.push(new Shape(setRectangle(scaledWidth, scaledHeight), setTranslationMatrix(x, y), [0.5, 0.5, 0.5, 1]));
}

// initialize buffer and Location
const colorLocation = gl.getUniformLocation(program, 'uColor');
const positionLocation = gl.getAttribLocation(program, 'aPosition');
const mMatrixLocation = gl.getUniformLocation(program, "mMatrix");
const vMatrixLocation = gl.getUniformLocation(program, "vMatrix");
const pMatrixLocation = gl.getUniformLocation(program, "pMatrix");
gl.enableVertexAttribArray(positionLocation);
const positionBuffer = gl.createBuffer();

// setup and pass the camera and view matrices
let cMatrix = mat3.create();
// make camera look at the center of the canvas
// glMatrix library does post-multiplication by default
// So, C = C * T(250, 250)
mat3.translate(cMatrix, cMatrix, [250, 250]);
let vMatrix = mat3.create();
mat3.invert(vMatrix, cMatrix);
gl.uniformMatrix3fv(vMatrixLocation, false, vMatrix);

// pass the projection Matrix
const pMatrix = [
    2/canvas.width,     0,                  0,
    0,                  2/canvas.height,    0,
    0,                  0,                  1,
]
gl.uniformMatrix3fv(pMatrixLocation, false, pMatrix);

// listening to the key events
document.addEventListener('keydown', (e)=>{
    if (e.key == 'w'){
        soldier.local_transform(setTranslationMatrix(0, 10));
    }
    else if (e.key == 's'){
        soldier.local_transform(setTranslationMatrix(0, -10));
    }
    else if (e.key == 'a'){
        soldier.local_transform(setTranslationMatrix(-10, 0));
    }
    else if (e.key == 'd'){
        soldier.local_transform(setTranslationMatrix(10, 0));
    }
    else if (e.key == 'ArrowLeft'){
        arm.local_transform(setRotationMatrix(10));
    }
    else if (e.key == 'ArrowRight'){
        arm.local_transform(setRotationMatrix(-10));
    }
    else if (e.key == 'ArrowUp'){
        sword.local_transform(setRotationMatrix(10));
    }
    else if (e.key == 'ArrowDown'){
        sword.local_transform(setRotationMatrix(-10));
    }
    else if (e.key == '['){
        // TODO: move camera left
    }
    else if (e.key == ']'){
        // TODO: move camera right      
    }
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    stones.draw();
    soldier.draw();
}, false);

// Create instruction in html
const instructions = document.createElement('div');
instructions.style.position = 'absolute';
instructions.style.top = '10px';
instructions.style.left = '520px';
instructions.style.color = 'black';
instructions.style.fontFamily = 'Arial, sans-serif';
instructions.style.fontSize = '14px';
instructions.style.lineHeight = '1.6';
instructions.innerHTML = `
    <h3>Controls:</h3>
    <p><strong>Movement:</strong></p>
    <p>W - Move Up<br>S - Move Down<br>A - Move Left<br>D - Move Right</p>
    <p><strong>Arm & Sword:</strong></p>
    <p>← - Rotate Arm Left<br>→ - Rotate Arm Right<br>↑ - Swing Sword Up<br>↓ - Swing Sword Down</p>
    <p><strong>Camera Translation:</strong></p>
    <p>[ - Move Camera Left<br>] - Move Camera Right</p>
`;
document.body.appendChild(instructions);

// Initial draw
gl.viewport(0, 0, canvas.width, canvas.height);
gl.clearColor(0, 0, 0, 1);
gl.clear(gl.COLOR_BUFFER_BIT);

stones.draw();
soldier.draw();


</script>
</body>
</html>